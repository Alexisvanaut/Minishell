To do list PARSING (alvanaut)

TO-DO Liste Parsing Minishell
ğŸ¯ Architecture gÃ©nÃ©rale
Structure de donnÃ©es principales

 DÃ©finir t_token (type, value, next)
 DÃ©finir t_command (args, redirections, next pour pipes)
 DÃ©finir t_redirect (type, filename, delimiter pour heredoc)
 CrÃ©er les Ã©numÃ©rations pour les types de tokens

Headers et includes

 CrÃ©er minishell.h avec toutes les structures
 Inclure les bonnes librairies (readline, stdio, stdlib, etc.)
 DÃ©finir les macros d'erreur

ğŸ“ Ã‰tape 1: Lexer/Tokenizer
Lecture de l'input

 ImplÃ©menter la boucle principale avec readline()
 GÃ©rer le prompt "minishell$ "
 Ajouter Ã  l'historique avec add_history()

Tokenisation de base

 Fonction tokenize() qui dÃ©coupe la ligne
 Identifier les mÃ©tacaractÃ¨res : |, <, >, >>, <<
 SÃ©parer les mots (arguments/commandes)
 GÃ©rer les espaces comme dÃ©limiteurs

Gestion des quotes

 DÃ©tecter les quotes simples '
 DÃ©tecter les quotes doubles "
 VÃ©rifier que les quotes sont fermÃ©es
 Dans les quotes simples : tout est littÃ©ral (pas d'expansion)
 Dans les quotes doubles : expansion des $ mais pas des autres mÃ©tacaractÃ¨res

ğŸ§  Ã‰tape 2: Parsing syntaxique
Validation syntaxique

 VÃ©rifier qu'on ne commence/finit pas par un pipe |
 VÃ©rifier qu'il n'y a pas deux pipes consÃ©cutifs ||
 VÃ©rifier que les redirections ont un fichier aprÃ¨s (<, >, >>)
 VÃ©rifier que heredoc << a un dÃ©limiteur

Construction de l'AST (liste de commandes)

 Parser les pipes pour sÃ©parer les commandes
 Pour chaque commande, extraire :

 Le nom de la commande (premier argument)
 Les arguments
 Les redirections d'entrÃ©e (<, <<)
 Les redirections de sortie (>, >>)



Gestion des redirections

 Identifier les redirections dans chaque commande
 Les retirer des arguments de la commande
 Les stocker dans la structure appropriÃ©e
 GÃ©rer les redirections multiples (derniÃ¨re gagne)

ğŸ”§ Ã‰tape 3: Expansions
Variables d'environnement

 DÃ©tecter les $VARIABLE dans les tokens
 RÃ©cupÃ©rer la valeur avec getenv()
 Remplacer $VAR par sa valeur
 Ne pas expanser dans les quotes simples
 Expanser dans les quotes doubles

Variables spÃ©ciales

 ImplÃ©menter $? (code de retour de la derniÃ¨re commande)
 GÃ©rer $0, $1, etc. si nÃ©cessaire (pas demandÃ© explicitement)
 GÃ©rer $$ (PID) si nÃ©cessaire

Cas limites d'expansion

 $ suivi de rien ou d'un caractÃ¨re invalide
 Variables inexistantes (expansion vers chaÃ®ne vide)
 Expansion dans diffÃ©rents contextes (commande, arguments, redirections)

ğŸ›¡ï¸ Ã‰tape 4: Gestion d'erreurs
Erreurs de syntaxe

 Messages d'erreur pour quotes non fermÃ©es
 Messages d'erreur pour redirections invalides
 Messages d'erreur pour pipes invalides
 Format des erreurs comme bash : bash: syntax error near unexpected token

Memory management

 Fonctions de libÃ©ration pour t_token
 Fonctions de libÃ©ration pour t_command
 Ã‰viter les leaks dans tous les cas d'erreur
 Tester avec valgrind

ğŸ§ª Ã‰tape 5: Tests et debug
Tests unitaires

 Tester le tokenizer avec diffÃ©rents inputs
 Tester la gestion des quotes
 Tester les expansions de variables
 Tester les cas d'erreur

Tests d'intÃ©gration

 Comparer avec bash pour les cas complexes
 Tester les combinaisons : pipes + redirections + quotes + variables
 Tester les cas limites (ligne vide, que des espaces, etc.)

Debug

 Fonction d'affichage de la liste de tokens (debug)
 Fonction d'affichage de la structure de commandes (debug)
 Tests avec des inputs progressifs (simple â†’ complexe)

ğŸ“‹ Ordre de dÃ©veloppement recommandÃ©

Structures de donnÃ©es et fonctions utilitaires de base
Tokenizer basique (sans quotes ni expansions)
Gestion des quotes simples et doubles
Parser syntaxique pour crÃ©er la structure de commandes
Expansions des variables d'environnement
Gestion d'erreurs et cas limites
Tests et optimisations

ğŸ’¡ Conseils

Commence simple : une commande sans arguments, puis ajoute la complexitÃ©
Utilise bash comme rÃ©fÃ©rence pour tous les comportements
Teste chaque fonction individuellement avant d'intÃ©grer
N'oublie pas que readline() peut avoir des leaks (c'est autorisÃ©)
Garde une variable globale pour les signaux uniquement